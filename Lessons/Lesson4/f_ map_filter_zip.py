# Повторяем map(), filter(), zip()
# Повторим уже знакомые вам по прошлым курсам функции для обработки
# последовательностей.


# Функция map()
# map(function, iterable) — принимает на вход функцию и последовательность.
# Функция применяется к каждому элементу последовательности и возвращает map
# итератор.

texts = ["Привет", "ЗДОРОВА", "привеТствую"]
res = map(lambda x: x.lower(), texts)
print(*res)

# В качестве функции использовали лямбду для вызова метода lower у каждого из
# переданных объектов. Объект итератор res был распакован в функцию print через
# символ “звёздочка”.

# ● Функция filter()
# filter(function, iterable) — принимает на вход функцию и последовательность. Если
# функция возвращает истину, элемент остаётся в последовательности. Как и map
# возвращает объект итератор.

numbers = [42, -73, 1024]
res = tuple(filter(lambda x: x > 0, numbers))
print(res)

# Лямбда фильтрует элементы больше нуля. Функция tuple преобразует итератор к
# кортежу с положительными числами.
# #
# ● Функция zip()
# zip(*iterables, strict=False) — принимает несколько последовательностей и
# итерируется по ним параллельно.
# Если передать ключевой аргумент strict=True, вызовет ошибку ValueError в случае
# разного числа элементов в каждой из последовательностей.

names = ["Иван", "Николай", "Пётр"]
salaries = [125_000, 96_000, 109_000]
awards = [0.1, 0.25, 0.13, 0.99]
for name, salary, award in zip(names, salaries, awards):
    print(f'{name} заработал {salary:.2f} денег и премию {salary * award:.2f}')
#
# Последовательно получаем имена, зарплату и процент премии из каждого списка.
# Итерация идёт слева направо.