# Области видимости: global и nonlocal
# Хорошая функция работает как чёрный ящик. Использует только переданные ей
# значения и возвращает ответ. Но в Python функции могут обращаться к внешним
# переменным без явной передачи в качестве аргумента.
# В Python есть несколько областей видимости:
# ● локальная — код внутри самой функции, т.е. переменные заданные в теле
# функции.
# ● глобальная — код модуля, т.е. переменные заданные в файле py содержащем
# функцию.
# ● не локальная — код внешней функции, исключающий доступ к глобальным
# переменным.
# Разберем на примерах.
# ● Локальные переменные:

def func(y: int) -> int:
    x = 100
    print(f'In func {x = }')
    return y + 1


x = 42
print(f'In main {x = }')
z = func(x)
print(f'{x = }\t{z = }')

# In main x = 42
# In func x = 100
# x = 42	z = 43

# Переменная x в теле функции и переменная x в основном коде - две разные
# переменные. Локальная область видимости функции создала свою переменную.
# Попробуем для эксперимента заменить строку с иксом на x += 100 В результате
# получаем ошибку UnboundLocalError: local variable 'x' referenced before assignment.
# Функция не смогла увеличить 42 на 100, т.к. переменные лишь для нас выглядят
# одинаково. Чёрный ящик не увидел x без его явной передачи в функцию.


# ● Глобальные переменные:
def func(y: int) -> int:
    global x
    x += 100
    print(f'In func {x = }') # Для демонстрации работы, но не
# для привычки принтить из функции
    return y + 1


x = 42
print(f'In main {x = }')
z = func(x)
print(f'{x = }\t{z = }')

# In main x = 42
# In func x = 142
# x = 142	z = 43

# Теперь переменная x в теле функции объявлена как глобальная. Мы получили
# доступ к внешнему иксу со значением 42 и смогли его увеличить. Изменение
# затронуло как внешний, так и внутренний икс.
# Важно! Не стоит злоупотреблять командой global. В 9 из 10 случаев переменную
# стоит передать как аргумент в функцию и вернуть ответ.

# ● Не локальные переменные:

def main(a):
    x = 1
    def func(y):
        nonlocal x
        x += 100
        print(f'In func {x = }') # Для демонстрации работы, но
# не для привычки принтить из функции
        return y + 1
    return x + func(a)


x = 42
print(f'In main {x = }')
z = main(x)
print(f'{x = }\t{z = }')


# In main x = 42
# In func x = 101
# x = 42	z = 44

# Функция func вложена в функцию main. Благодаря команде nonlocal мы смогли
# получить доступ к x = 1. В результат внутри func x увеличился до 101. В отличии от
# команды global, мы не смогли увидеть внешний x = 42. nonlocal позволяет заглянуть
# на верхний уровень вложенности, но не выходить на глобальные переменные
# модуля.