# Десериализация
# Проведём обратные операции. Набор байт мы уже восстанавливали, когда
# разбирались с безопасностью данных. Уточним детали.
import pickle


data = b'\x80\x04\x95\x94\x00\x00\x00\x00\x00\x00\x00}\x94(\x8c\x07numbers\x94]\x94(K*G@\x10\x90\xe5`A\x897\x8c\x08builtins\x94\x8c\x07complex\x94\x93\x94G@\x1c\x00\x00\x00\x00\x00\x00G@\x08\x00\x00\x00\x00\x00\x00\x86\x94R\x94e\x8c\tfunctions\x94\x8c\x08builtins\x94\x8c\x03sum\x94\x93\x94h\t\x8c\x03max\x94\x93\x94\x86\x94\x8c\x06others\x94\x8f\x94(\x89\x88\x8c\x0cHello world!\x94\x90u.'

new_dict = pickle.loads(data)
print(f'{new_dict = }')

# Функция получила на вход набор байт и восстановила из них исходный словарь.
# Уточним, что loads имеет ряд дополнительных параметров: fix_imports=True,
# encoding='ASCII', errors='strict'. Они нужны для десериализации объектов созданных
# в Python 2. А так как поддержка второй версии Python завершена в 2020 году, нет
# смысла разбирать назначение параметров.
# В финале загрузим данные из файла my_dict.pikle, который создали ранее.

import pickle


def func(a, b, c):
    return a * b * c


with open('my_dict.pickle', 'rb') as f:
    new_dict = pickle.load(f)
print(f'{new_dict = }')
print(f'{new_dict["functions"][0](2, 3, 4) = }')

# Содержимое словаря в точности соответствует исходному. Но есть одно но. При
# вызове функции func, которая лежит в нулевой ячейке кортежа по ключу functions
# мы получили не сумму трёх чисел, а произведение. В файле, где произведена
# десериализация есть функция func, которая умножает числа. Модуль pickle указал в
# словаре её, а не исходную. Более того, если бы функции с нужным именем не было,
# десериализация завершилась бы ошибкой.
